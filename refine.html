
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Music Preferences Visualizer (ECharts)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <!-- Telegram WebApp script -->
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <!-- ECharts library -->
  <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif; margin: 10px;
      background: #f0f0f0; color: #333;
    }
    h2 { text-align: center; }
    #charts { display: flex; flex-direction: column; align-items: center; }
    .chart-box { width: 300px; height: 300px; max-width: 90%; margin: 20px 0; }
    #controls { margin: 10px 0; text-align: center; }
    #sliders .slider-row {
      margin: 5px 0; display: flex; align-items: center;
    }
    .slider-row span.dim-name { width: 200px; text-align: right; margin-right: 10px; }
    .slider-row input[type=range] { flex: 1; }
    .slider-row span.dim-value { width: 40px; text-align: left; margin-left: 10px; }
    #year-controls { margin: 10px 0; }
    #year-controls select { margin: 0 5px; }
    #applyBtn { padding: 8px 16px; font-size: 16px; }
  </style>
</head>
<body>
  <h2>ðŸŽµ Refine Your Music Profile</h2>
  <div id="charts">
    <div id="mainRadar" class="chart-box"></div>
    <div id="detailRadar" class="chart-box"></div>
  </div>
  <div id="controls">
    <label for="categorySelect"><strong>Category:</strong></label>
    <select id="categorySelect"></select>
  </div>
  <div id="sliders"></div>
  <div id="year-controls">
    <label><strong>Year From:</strong>
      <select id="yearFrom"></select>
    </label>
    <label><strong>To:</strong>
      <select id="yearTo"></select>
    </label>
  </div>
  <div style="text-align:center;">
    <button id="applyBtn">âœ… Apply Changes</button>
  </div>

  <script>
    (() => {
      const tg = window.Telegram.WebApp;
      tg.expand();

      // 1. Parse initial vector and year range from URL
      const urlParams = new URLSearchParams(window.location.search);
      const vectorParam = urlParams.get('vector');
      let initialVector = [];
      if (vectorParam) {
        initialVector = vectorParam.split(',').map(x => {
          const val = parseInt(x, 10);
          return isNaN(val) ? 0 : val;
        });
      }
      while (initialVector.length < 58) initialVector.push(0);
      initialVector = initialVector.slice(0, 58);
      const yearFromParam = urlParams.get('year_from');
      const yearToParam   = urlParams.get('year_to');

      // 2. Define categories and sub-dimension labels
      const categories = [
        { name: "Vocals", length: 7, labels: [
            "Vocal Register", "Vocal Timbre Thin/Full", "Vocal Breathiness",
            "Vocal Smoothness", "Vocal Grittiness", "Vocal Nasality", "Vocal Accompaniment"
          ] },
        { name: "Harmony", length: 2, labels: [
            "Minor/Major Tonality", "Harmonic Sophistication"
          ] },
        { name: "Rhythm", length: 10, labels: [
            "Tempo", "Cut Time Feel", "Triple Meter", "Compound Meter", "Odd Meter",
            "Swing Feel", "Shuffle Feel", "Syncopation", "Backbeat", "Danceability"
          ] },
        { name: "Instrumentation", length: 16, labels: [
            "Drum Set", "Drum Aggressiveness", "Synthetic Drums", "Percussion",
            "Electric Guitar", "Guitar Distortion", "Acoustic Guitar", "String Ensemble",
            "Horn Ensemble", "Piano", "Organ", "Rhodes", "Synthesizer", "Synth Timbre",
            "Bass Guitar", "Reed Instrument"
          ] },
        { name: "Lyrics", length: 8, labels: [
            "Angry Lyrics", "Sad Lyrics", "Happy Lyrics", "Humorous Lyrics", "Love Lyrics",
            "Political Lyrics", "Abstract Lyrics", "Explicit Lyrics"
          ] },
        { name: "Sonority", length: 6, labels: [
            "Live Recording", "Audio Production", "Aural Intensity",
            "Acoustic Sonority", "Electric Sonority", "Synthetic Sonority"
          ] },
        { name: "Composition", length: 9, labels: [
            "Focus Lead Vocal", "Focus Lyrics", "Focus Melody", "Focus Vocal Acc.",
            "Focus Groove", "Focus Arrangement", "Focus Form", "Focus Riffs", "Focus Performance"
          ] }
      ];
      let idx = 0;
      categories.forEach(cat => { cat.start = idx; idx += cat.length; });

      // 3. Populate category select options
      const categorySelect = document.getElementById('categorySelect');
      categories.forEach((cat, i) => {
        const opt = document.createElement('option');
        opt.value = i;
        opt.textContent = cat.name;
        categorySelect.appendChild(opt);
      });
      categorySelect.value = "0";

      // 4. Populate year range select options
      const yearFromSel = document.getElementById('yearFrom');
      const yearToSel   = document.getElementById('yearTo');
      const minYear = 1900, maxYear = 2025;
      for (let y = minYear; y <= maxYear; y++) {
        const optF = document.createElement('option');
        optF.value = y; optF.textContent = y;
        yearFromSel.appendChild(optF);
        const optT = document.createElement('option');
        optT.value = y; optT.textContent = y;
        yearToSel.appendChild(optT);
      }
      yearFromSel.value = yearFromParam || minYear;
      yearToSel.value   = yearToParam   || maxYear;

      // 5. Helper: calculate category averages
      function calcCategoryAverages(vec) {
        return categories.map(cat => {
          let sum = 0;
          for (let j = 0; j < cat.length; j++) {
            let val = vec[cat.start + j];
            if (isNaN(val)) val = 0;
            sum += val;
          }
          return cat.length ? Math.round(sum / cat.length) : 0;
        });
      }
      let categoryData = calcCategoryAverages(initialVector);

      // 6. Initialize ECharts radar instances
      const mainChart   = echarts.init(document.getElementById('mainRadar'));
      const detailChart = echarts.init(document.getElementById('detailRadar'));

      // Main 7-category radar configuration
      const mainOption = {
        tooltip: {},  // hover tooltip
        radar: {
          indicator: categories.map(cat => ({ name: cat.name, max: 100 })),
          radius: '70%'  // size of radar relative to container
        },
        series: [{
          name: 'Overall Profile',
          type: 'radar',
          data: [{ value: categoryData, name: 'Profile' }],
          areaStyle: { opacity: 0.2 },
          itemStyle: { color: '#884EA0' }  // purple
        }]
      };
      mainChart.setOption(mainOption);

      // 7. Function to render detail radar and sliders for a given category
      function renderDetailCategory(catIndex) {
        const cat = categories[catIndex];
        // Prepare detail radar option for this category
        const indicators = cat.labels.map(label => ({ name: label, max: 100 }));
        const values = initialVector.slice(cat.start, cat.start + cat.length).map(v => isNaN(v) ? 0 : v);
        const detailOption = {
          tooltip: {},
          radar: {
            indicator: indicators,
            radius: '70%'
          },
          series: [{
            name: cat.name + " Details",
            type: 'radar',
            data: [{ value: values, name: cat.name }],
            areaStyle: { opacity: 0.2 },
            itemStyle: { color: '#36A2EB' }  // blue
          }]
        };
        detailChart.setOption(detailOption, true);  // notMerge: replace previous option

        // Build sliders for this category's sub-dimensions
        const slidersDiv = document.getElementById('sliders');
        slidersDiv.innerHTML = "";
        for (let j = 0; j < cat.length; j++) {
          const dimIndex = cat.start + j;
          const dimName  = cat.labels[j];
          const dimValue = isNaN(initialVector[dimIndex]) ? 0 : initialVector[dimIndex];

          const row = document.createElement('div');
          row.className = 'slider-row';
          const nameSpan = document.createElement('span');
          nameSpan.className = 'dim-name';
          nameSpan.textContent = dimName;
          const slider = document.createElement('input');
          slider.type = 'range'; slider.min = 0; slider.max = 100;
          slider.value = dimValue;
          slider.dataset.index = dimIndex;
          const valueSpan = document.createElement('span');
          valueSpan.className = 'dim-value';
          valueSpan.textContent = dimValue;
          // Slider input event: update values and charts
          slider.addEventListener('input', () => {
            const val = parseInt(slider.value, 10);
            const idx = parseInt(slider.dataset.index, 10);
            initialVector[idx] = isNaN(val) ? 0 : val;
            valueSpan.textContent = val;
            // Update detail chart's data for this category
            const newValues = initialVector.slice(cat.start, cat.start + cat.length);
            detailChart.setOption({ series: [{ data: [{ value: newValues, name: cat.name }] }] });
            // Update main chart's average for this category
            const newAvg = calcCategoryAverages(initialVector)[catIndex];
            categoryData[catIndex] = newAvg;
            mainChart.setOption({ series: [{ data: [{ value: categoryData, name: 'Profile' }] }] });
          });
          row.appendChild(nameSpan);
          row.appendChild(slider);
          row.appendChild(valueSpan);
          slidersDiv.appendChild(row);
        }
      }

      // 8. Initial render for category 0
      renderDetailCategory(0);

      // 9. Handle category selection change
      categorySelect.addEventListener('change', () => {
        const newIdx = parseInt(categorySelect.value, 10);
        renderDetailCategory(newIdx);
      });

      // 10. Apply changes (send data to bot)
      document.getElementById('applyBtn').addEventListener('click', () => {
        const fromYear = parseInt(yearFromSel.value, 10);
        const toYear   = parseInt(yearToSel.value, 10);
        if (fromYear > toYear) {
          alert("The 'From Year' must be <= 'To Year'.");
          return;
        }
        const data = {
          vector: initialVector.map(x => Math.round(x)),
          year_from: fromYear,
          year_to: toYear
        };
        tg.sendData(JSON.stringify(data));
        tg.close();
      });
    })();
  </script>
</body>
</html>
